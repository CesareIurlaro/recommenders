From 1af72edfc7e887b921560e2b109bc6645cda059f Mon Sep 17 00:00:00 2001
From: Marcel Bruch <marcel.bruch@gmail.com>
Date: Tue, 12 Apr 2011 10:35:47 +0200
Subject: [PATCH] added EmptySetClearer to analyzer pipeline

---
 .../EmptySetsClearerCompilationUnitFinalizer.java  |   42 +++
 .../analysis/codeelements/MethodDeclaration.java   |   12 +-
 .../analysis/codeelements/ObjectInstanceKey.java   |  130 +++++-----
 .../analysis/codeelements/TypeDeclaration.java     |  188 ++++++++-------
 .../entrypoints/RecommendersEntrypoint.java        |   29 +--
 .../analysis/utils/InstanceCallGraphBuilder.java   |  270 +++++++++++---------
 .../analysis/utils/LocalNamesCollector.java        |    5 +
 7 files changed, 384 insertions(+), 292 deletions(-)
 create mode 100644 org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/analyzers/EmptySetsClearerCompilationUnitFinalizer.java

diff --git a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/analyzers/EmptySetsClearerCompilationUnitFinalizer.java b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/analyzers/EmptySetsClearerCompilationUnitFinalizer.java
new file mode 100644
index 0000000..30201c3
--- /dev/null
+++ b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/analyzers/EmptySetsClearerCompilationUnitFinalizer.java
@@ -0,0 +1,42 @@
+package org.eclipse.recommenders.internal.commons.analysis.analyzers;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.recommenders.internal.commons.analysis.codeelements.CompilationUnit;
+import org.eclipse.recommenders.internal.commons.analysis.codeelements.CompilationUnitVisitor;
+import org.eclipse.recommenders.internal.commons.analysis.codeelements.MethodDeclaration;
+import org.eclipse.recommenders.internal.commons.analysis.codeelements.ObjectInstanceKey;
+import org.eclipse.recommenders.internal.commons.analysis.codeelements.TypeDeclaration;
+
+import com.google.inject.Singleton;
+import com.ibm.wala.classLoader.IClass;
+@Singleton
+public class EmptySetsClearerCompilationUnitFinalizer implements ICompilationUnitFinalizer{
+
+	@Override
+	public void finalizeClass(CompilationUnit compilationUnit,
+			IClass exampleClass, IProgressMonitor monitor) {
+		compilationUnit.accept(new CompilationUnitVisitor(){
+		
+			@Override
+			public boolean visit(TypeDeclaration type) {
+				type.clearEmptySets();
+				return true;
+			}
+			@Override
+			public boolean visit(MethodDeclaration method) {
+				method.clearEmptySets();
+				return true;
+			}
+			
+			@Override
+			public boolean visit(ObjectInstanceKey objectInstanceKey) {
+				objectInstanceKey.clearEmptySets();
+				return false;
+			}
+			
+		});
+		
+	}
+	
+}
+
diff --git a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/codeelements/MethodDeclaration.java b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/codeelements/MethodDeclaration.java
index 2bd1a04..7632b37 100644
--- a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/codeelements/MethodDeclaration.java
+++ b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/codeelements/MethodDeclaration.java
@@ -105,6 +105,12 @@ public class MethodDeclaration implements INamedCodeElement {
         this.variables = variables;
     }
 
+
+    public void clearEmptySets(){
+    	if(nestedTypes.isEmpty()) nestedTypes=null;
+    	if(objects.isEmpty()) objects=null;
+    }
+
     public synchronized Set<Variable> getVariables() {
         if (variables == null) {
             initVariables();
@@ -125,13 +131,17 @@ public class MethodDeclaration implements INamedCodeElement {
     @Override
     public void accept(final CompilationUnitVisitor v) {
         if (v.visit(this)) {
+        	if (nestedTypes != null)
             for (final TypeDeclaration nestedType : nestedTypes) {
                 nestedType.accept(v);
             }
+        	if (objects != null)
             for (final ObjectInstanceKey obj : objects) {
                 obj.accept(v);
             }
-            for (final Variable var : getVariables()) {
+        	if (variables != null)
+            for (final 
+            		Variable var : getVariables()) {
                 var.accept(v);
             }
         }
diff --git a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/codeelements/ObjectInstanceKey.java b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/codeelements/ObjectInstanceKey.java
index 513ae40..da9ab31 100644
--- a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/codeelements/ObjectInstanceKey.java
+++ b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/codeelements/ObjectInstanceKey.java
@@ -20,63 +20,75 @@ import org.eclipse.recommenders.commons.utils.names.ITypeName;
 import com.google.common.collect.Sets;
 
 public class ObjectInstanceKey implements ICodeElement {
-    public static enum Kind {
-        LOCAL, FIELD, PARAMETER, RETURN
-    }
-
-    public static ObjectInstanceKey create(final ITypeName varType, final Kind kind) {
-        final ObjectInstanceKey recValue = new ObjectInstanceKey();
-        recValue.type = varType;
-        recValue.kind = kind;
-        return recValue;
-    }
-
-    public ITypeName type;
-
-    public Set<String> names = Sets.newTreeSet();
-
-    public Kind kind;
-
-    public DefinitionSite definitionSite;
-
-    public Set<ParameterCallSite> parameterCallSites = Sets.newHashSet();
-
-    public Set<ReceiverCallSite> receiverCallSites = Sets.newHashSet();
-
-    public boolean isThis() {
-        if (names.contains("this")) {
-            return true;
-        }
-        for (final ReceiverCallSite callsite : receiverCallSites) {
-            if (callsite.isThis()) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    public Set<IMethodName> getInvokedMethods() {
-        final Set<IMethodName> res = Sets.newTreeSet();
-        for (final ReceiverCallSite callsite : receiverCallSites) {
-            res.add(callsite.targetMethod);
-        }
-        return res;
-    }
-
-    @Override
-    public String toString() {
-        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);
-    }
-
-    @Override
-    public void accept(final CompilationUnitVisitor v) {
-        if (v.visit(this)) {
-            for (final ReceiverCallSite callsite : receiverCallSites) {
-                callsite.accept(v);
-            }
-            for (final ParameterCallSite callsite : parameterCallSites) {
-                callsite.accept(v);
-            }
-        }
-    }
+	public static enum Kind {
+		LOCAL, FIELD, PARAMETER, RETURN
+	}
+
+	public static ObjectInstanceKey create(final ITypeName varType,
+			final Kind kind) {
+		final ObjectInstanceKey recValue = new ObjectInstanceKey();
+		recValue.type = varType;
+		recValue.kind = kind;
+		return recValue;
+	}
+
+	public ITypeName type;
+
+	public Set<String> names = Sets.newTreeSet();
+
+	public Kind kind;
+
+	public DefinitionSite definitionSite;
+
+	public Set<ParameterCallSite> parameterCallSites = Sets.newHashSet();
+
+	public Set<ReceiverCallSite> receiverCallSites = Sets.newHashSet();
+
+	public boolean isThis() {
+		if (names.contains("this")) {
+			return true;
+		}
+		for (final ReceiverCallSite callsite : receiverCallSites) {
+			if (callsite.isThis()) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public Set<IMethodName> getInvokedMethods() {
+		final Set<IMethodName> res = Sets.newTreeSet();
+		for (final ReceiverCallSite callsite : receiverCallSites) {
+			res.add(callsite.targetMethod);
+		}
+		return res;
+	}
+
+	public void clearEmptySets() {
+		if (parameterCallSites.isEmpty())
+			parameterCallSites = null;
+		if (receiverCallSites.isEmpty())
+			receiverCallSites = null;
+		if (names.isEmpty())
+			names = null;
+
+	}
+
+	@Override
+	public String toString() {
+		return ToStringBuilder.reflectionToString(this,
+				ToStringStyle.MULTI_LINE_STYLE);
+	}
+
+	@Override
+	public void accept(final CompilationUnitVisitor v) {
+		if (v.visit(this)) {
+			for (final ReceiverCallSite callsite : receiverCallSites) {
+				callsite.accept(v);
+			}
+			for (final ParameterCallSite callsite : parameterCallSites) {
+				callsite.accept(v);
+			}
+		}
+	}
 }
diff --git a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/codeelements/TypeDeclaration.java b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/codeelements/TypeDeclaration.java
index a1365bb..662ffb0 100755
--- a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/codeelements/TypeDeclaration.java
+++ b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/codeelements/TypeDeclaration.java
@@ -22,90 +22,106 @@ import com.google.common.collect.Sets;
 
 public class TypeDeclaration implements INamedCodeElement {
 
-    public static TypeDeclaration create() {
-        final TypeDeclaration type = new TypeDeclaration();
-        return type;
-    }
-
-    public static TypeDeclaration create(final ITypeName typeName, final ITypeName superclassName) {
-        final TypeDeclaration type = new TypeDeclaration();
-        type.name = typeName;
-        type.superclass = superclassName;
-        return type;
-    }
-
-    @Override
-    public IName getName() {
-        return name;
-    }
-
-    /**
-     * use {@link #create(ITypeName, ITypeName)} to create an instance of this
-     * class.
-     */
-    protected TypeDeclaration() {
-        // no-one should instantiate this class directly
-    }
-
-    public ITypeName name;
-
-    public ITypeName superclass;
-
-    public Set<ITypeName> interfaces = Sets.newHashSet();
-
-    public Set<ITypeName> fields = Sets.newHashSet();
-
-    public Set<MethodDeclaration> methods = Sets.newHashSet();
-
-    public int line;
-
-    public Set<TypeDeclaration> memberTypes = Sets.newHashSet();
-
-    public int modifiers;
-
-    public void accept(final CompilationUnitVisitor v) {
-
-        if (v.visit(this)) {
-            for (final TypeDeclaration type : memberTypes) {
-                type.accept(v);
-            }
-            for (final MethodDeclaration method : methods) {
-                method.accept(v);
-            }
-        }
-    }
-
-    @Override
-    public String toString() {
-        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);
-    }
-
-    public MethodDeclaration findMethod(final IMethodName methodName) {
-        for (final MethodDeclaration method : methods) {
-            if (method.name == methodName) {
-                return method;
-            }
-        }
-        // its not one of our methods declared in here... check our nested types
-        // next:
-        for (final TypeDeclaration nestedType : memberTypes) {
-            final MethodDeclaration res = nestedType.findMethod(methodName);
-            if (res != null) {
-                return res;
-            }
-        }
-        // its not in one of our nested types. Check each method whether it
-        // contains a nested type that declares this
-        // method:
-        for (final MethodDeclaration method : methods) {
-            for (final TypeDeclaration nestedType : method.nestedTypes) {
-                final MethodDeclaration res = nestedType.findMethod(methodName);
-                if (res != null) {
-                    return res;
-                }
-            }
-        }
-        // sorry, we couldn't find any matching method.
-        return null;
-    }
+	public static TypeDeclaration create() {
+		final TypeDeclaration type = new TypeDeclaration();
+		return type;
+	}
+
+	public static TypeDeclaration create(final ITypeName typeName,
+			final ITypeName superclassName) {
+		final TypeDeclaration type = new TypeDeclaration();
+		type.name = typeName;
+		type.superclass = superclassName;
+		return type;
+	}
+
+	@Override
+	public IName getName() {
+		return name;
+	}
+
+	/**
+	 * use {@link #create(ITypeName, ITypeName)} to create an instance of this
+	 * class.
+	 */
+	protected TypeDeclaration() {
+		// no-one should instantiate this class directly
+	}
+
+	public ITypeName name;
+
+	public ITypeName superclass;
+
+	public Set<ITypeName> interfaces = Sets.newHashSet();
+
+	public Set<ITypeName> fields = Sets.newHashSet();
+
+	public Set<MethodDeclaration> methods = Sets.newHashSet();
+
+	public int line;
+
+	public Set<TypeDeclaration> memberTypes = Sets.newHashSet();
+
+	public int modifiers;
+
+	public void accept(final CompilationUnitVisitor v) {
+
+		if (v.visit(this)) {
+
+			if (memberTypes != null)
+				for (final TypeDeclaration type : memberTypes) {
+					type.accept(v);
+				}
+			if (methods != null)
+				for (final MethodDeclaration method : methods) {
+					method.accept(v);
+				}
+		}
+	}
+
+	public void clearEmptySets() {
+		if (interfaces.isEmpty())
+			interfaces = null;
+		if (fields.isEmpty())
+			fields = null;
+		if (methods.isEmpty())
+			methods = null;
+		if (memberTypes.isEmpty())
+			memberTypes = null;
+	}
+
+	@Override
+	public String toString() {
+		return ToStringBuilder.reflectionToString(this,
+				ToStringStyle.MULTI_LINE_STYLE);
+	}
+
+	public MethodDeclaration findMethod(final IMethodName methodName) {
+		for (final MethodDeclaration method : methods) {
+			if (method.name == methodName) {
+				return method;
+			}
+		}
+		// its not one of our methods declared in here... check our nested types
+		// next:
+		for (final TypeDeclaration nestedType : memberTypes) {
+			final MethodDeclaration res = nestedType.findMethod(methodName);
+			if (res != null) {
+				return res;
+			}
+		}
+		// its not in one of our nested types. Check each method whether it
+		// contains a nested type that declares this
+		// method:
+		for (final MethodDeclaration method : methods) {
+			for (final TypeDeclaration nestedType : method.nestedTypes) {
+				final MethodDeclaration res = nestedType.findMethod(methodName);
+				if (res != null) {
+					return res;
+				}
+			}
+		}
+		// sorry, we couldn't find any matching method.
+		return null;
+	}
 }
diff --git a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/entrypoints/RecommendersEntrypoint.java b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/entrypoints/RecommendersEntrypoint.java
index 3744ed8..ecd8f21 100755
--- a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/entrypoints/RecommendersEntrypoint.java
+++ b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/entrypoints/RecommendersEntrypoint.java
@@ -40,34 +40,7 @@ public class RecommendersEntrypoint extends DefaultEntrypoint {
         this(method, method.getDeclaringClass().getClassHierarchy());
     }
 
-    @Override
-    public SSAAbstractInvokeInstruction addCall(final AbstractRootMethod m) {
-        final int[] paramValues = new int[getNumberOfParameters()];
-        final CallSiteReference site = makeSite(0);
-        if (site == null) {
-            return null;
-        }
-        for (int j = 0; j < paramValues.length; j++) {
-            final int paramValue = paramValues[j];
-            if (isThisParameter(site, j)) {
-                final TypeReference typeRef = getParameterTypes(paramValue)[0];
-                final NewSiteReference thisNewSiteRef = NewSiteReferenceForThis.create(m.getStatements().length,
-                        typeRef);
-                m.addNewInstruction(paramValue, thisNewSiteRef);
-            }
-            paramValues[j] = makeArgument(m, j);
-            if (paramValue == -1) {
-                // there was a problem
-                return null;
-            }
-        }
-
-        return m.addInvocation(paramValues, site);
-    }
-
-    private boolean isThisParameter(final CallSiteReference site, final int j) {
-        return j == 0 && !site.isStatic();
-    }
+   
 
     /**
      * Creates allocation sites for all non-primitive parameters. If a new
diff --git a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/utils/InstanceCallGraphBuilder.java b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/utils/InstanceCallGraphBuilder.java
index 18b3e60..a090d69 100755
--- a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/utils/InstanceCallGraphBuilder.java
+++ b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/utils/InstanceCallGraphBuilder.java
@@ -40,126 +40,160 @@ import com.ibm.wala.ipa.cha.IClassHierarchy;
 import com.ibm.wala.ipa.summaries.BypassClassTargetSelector;
 import com.ibm.wala.ipa.summaries.BypassMethodTargetSelector;
 import com.ibm.wala.ipa.summaries.XMLMethodSummaryReader;
+import com.ibm.wala.util.MonitorUtil.IProgressMonitor;
 import com.ibm.wala.util.strings.Atom;
 
 public class InstanceCallGraphBuilder implements ICallGraphBuilder {
-    public static void build(final InstanceCallGraphBuilder cgBuilder, final Collection<Entrypoint> entryPoints,
-            final IClass thisType) {
-        cgBuilder.setThisType(thisType);
-        cgBuilder.setEntryPoints(entryPoints);
-        cgBuilder.buildClassTargetSelector();
-        cgBuilder.buildMethodTargetSelector();
-        cgBuilder.buildContextSelector();
-        cgBuilder.buildContextInterpretor();
-        cgBuilder.buildCallGraph();
-    }
-
-    private final AnalysisOptions options;
-
-    private SSAPropagationCallGraphBuilder callGraphBuilder;
-
-    private CallGraph callGraph;
-
-    private IClass thisType;
-
-    private final AnalysisCache cache;
-
-    private final XMLMethodSummaryReader summary;
-
-    @Inject
-    public InstanceCallGraphBuilder(final AnalysisOptions options, final AnalysisCache cache,
-            final XMLMethodSummaryReader summary) {
-        this.options = ensureIsNotNull(options);
-        this.cache = ensureIsNotNull(cache);
-        this.summary = ensureIsNotNull(summary);
-    }
-
-    /**
-     * Call this method before any other method!
-     */
-    public void setThisType(final IClass clazz) {
-        this.thisType = clazz;
-        callGraphBuilder = initializeBuilder(options, cache, clazz.getClassHierarchy(), summary);
-    }
-
-    private SSAPropagationCallGraphBuilder initializeBuilder(final AnalysisOptions options, final AnalysisCache cache,
-            final IClassHierarchy cha, final XMLMethodSummaryReader summary) {
-
-        // return Util.makeVanillaZeroOneCFABuilder(options, cache, cha,
-        // cha.getScope(), null, null);
-
-        options.setSelector(new ClassHierarchyMethodTargetSelector(cha));
-        options.setSelector(new ClassHierarchyClassTargetSelector(cha));
-
-        final MethodTargetSelector ms = new BypassMethodTargetSelector(options.getMethodTargetSelector(),
-                summary.getSummaries(), summary.getIgnoredPackages(), cha);
-        options.setSelector(ms);
-        final AnalysisScope scope = cha.getScope();
-        final ClassTargetSelector cs = new BypassClassTargetSelector(options.getClassTargetSelector(),
-                summary.getAllocatableClasses(), cha, cha.getLoader(scope.getLoader(Atom
-                        .findOrCreateUnicodeAtom("Synthetic"))));
-        options.setSelector(cs);
-        final SSAContextInterpreter appContextInterpreter = null;
-        final ContextSelector appContextSelector = null;
-        final ZeroXCFABuilder builder = new ZeroXCFABuilder(cha, options, cache, appContextSelector,
-                appContextInterpreter, ZeroXInstanceKeys.ALLOCATIONS | ZeroXInstanceKeys.CONSTANT_SPECIFIC);
-        return builder;
-    }
-
-    public void setEntryPoints(final Collection<Entrypoint> entrypoints) {
-        callGraphBuilder.getOptions().setEntrypoints(entrypoints);
-    }
-
-    @Override
-    public void buildClassTargetSelector() {
-        final BypassingAbstractClassesClassTargetSelector myClassTargetSelector = new BypassingAbstractClassesClassTargetSelector();
-        // options.setSelector(myClassTargetSelector);
-    }
-
-    @Override
-    public void buildMethodTargetSelector() {
-        final MethodTargetSelector delegate = options.getMethodTargetSelector();
-        final RestrictedDeclaringClassMethodTargetSelector mySelector = new RestrictedDeclaringClassMethodTargetSelector(
-                delegate, thisType, callGraphBuilder);
-        options.setSelector(mySelector);
-    }
-
-    @Override
-    public void buildContextSelector() {
-        // final ContextSelector delegate =
-        // callGraphBuilder.getContextSelector();
-        // final OneLevelSiteContextSelector selector = new
-        // OneLevelSiteContextSelector(delegate);
-        // callGraphBuilder.setContextSelector(selector);
-        final ContextSelector delegate = callGraphBuilder.getContextSelector();
-        final nCFAContextSelector newContextSelector = new nCFAContextSelector(5, delegate);
-        callGraphBuilder.setContextSelector(newContextSelector);
-    }
-
-    @Override
-    public void buildContextInterpretor() {
-        // stick with the default one.
-        // final RTAContextInterpreter contextInterpreter =
-        // callGraphBuilder.getContextInterpreter();
-    }
-
-    @Override
-    public void buildCallGraph() {
-        try {
-            callGraph = callGraphBuilder.makeCallGraph(options);
-        } catch (final Exception e) {
-            throw Throws.throwUnhandledException(e);
-        }
-    }
-
-    @Override
-    public CallGraph getCallGraph() {
-        return callGraph;
-    }
-
-    @Override
-    public PointerAnalysis getPointerAnalysis() {
-        return callGraphBuilder.getPointerAnalysis();
-    }
+	public static void build(final InstanceCallGraphBuilder cgBuilder,
+			final Collection<Entrypoint> entryPoints, final IClass thisType) {
+		cgBuilder.setThisType(thisType);
+		cgBuilder.setEntryPoints(entryPoints);
+		cgBuilder.buildClassTargetSelector();
+		cgBuilder.buildMethodTargetSelector();
+		cgBuilder.buildContextSelector();
+		cgBuilder.buildContextInterpretor();
+		cgBuilder.buildCallGraph();
+	}
+
+	private final AnalysisOptions options;
+
+	private SSAPropagationCallGraphBuilder callGraphBuilder;
+
+	private CallGraph callGraph;
+
+	private IClass thisType;
+
+	private final AnalysisCache cache;
+
+	private final XMLMethodSummaryReader summary;
+
+	@Inject
+	public InstanceCallGraphBuilder(final AnalysisOptions options,
+			final AnalysisCache cache, final XMLMethodSummaryReader summary) {
+		this.options = ensureIsNotNull(options);
+		this.cache = ensureIsNotNull(cache);
+		this.summary = ensureIsNotNull(summary);
+	}
+
+	/**
+	 * Call this method before any other method!
+	 */
+	public void setThisType(final IClass clazz) {
+		this.thisType = clazz;
+		callGraphBuilder = initializeBuilder(options, cache,
+				clazz.getClassHierarchy(), summary);
+	}
+
+	private SSAPropagationCallGraphBuilder initializeBuilder(
+			final AnalysisOptions options, final AnalysisCache cache,
+			final IClassHierarchy cha, final XMLMethodSummaryReader summary) {
+
+		// return Util.makeVanillaZeroOneCFABuilder(options, cache, cha,
+		// cha.getScope(), null, null);
+
+		options.setSelector(new ClassHierarchyMethodTargetSelector(cha));
+		options.setSelector(new ClassHierarchyClassTargetSelector(cha));
+
+		final MethodTargetSelector ms = new BypassMethodTargetSelector(
+				options.getMethodTargetSelector(), summary.getSummaries(),
+				summary.getIgnoredPackages(), cha);
+		options.setSelector(ms);
+		final AnalysisScope scope = cha.getScope();
+		final ClassTargetSelector cs = new BypassClassTargetSelector(
+				options.getClassTargetSelector(),
+				summary.getAllocatableClasses(), cha, cha.getLoader(scope
+						.getLoader(Atom.findOrCreateUnicodeAtom("Synthetic"))));
+		options.setSelector(cs);
+		final SSAContextInterpreter appContextInterpreter = null;
+		final ContextSelector appContextSelector = null;
+		final ZeroXCFABuilder builder = new ZeroXCFABuilder(cha, options,
+				cache, appContextSelector, appContextInterpreter,
+				ZeroXInstanceKeys.ALLOCATIONS
+						| ZeroXInstanceKeys.CONSTANT_SPECIFIC);
+		return builder;
+	}
+
+	public void setEntryPoints(final Collection<Entrypoint> entrypoints) {
+		callGraphBuilder.getOptions().setEntrypoints(entrypoints);
+	}
+
+	@Override
+	public void buildClassTargetSelector() {
+		final BypassingAbstractClassesClassTargetSelector myClassTargetSelector = new BypassingAbstractClassesClassTargetSelector();
+		// options.setSelector(myClassTargetSelector);
+	}
+
+	@Override
+	public void buildMethodTargetSelector() {
+		final MethodTargetSelector delegate = options.getMethodTargetSelector();
+		final RestrictedDeclaringClassMethodTargetSelector mySelector = new RestrictedDeclaringClassMethodTargetSelector(
+				delegate, thisType, callGraphBuilder);
+		options.setSelector(mySelector);
+	}
+
+	@Override
+	public void buildContextSelector() {
+		// final ContextSelector delegate =
+		// callGraphBuilder.getContextSelector();
+		// final OneLevelSiteContextSelector selector = new
+		// OneLevelSiteContextSelector(delegate);
+		// callGraphBuilder.setContextSelector(selector);
+		final ContextSelector delegate = callGraphBuilder.getContextSelector();
+		final nCFAContextSelector newContextSelector = new nCFAContextSelector(
+				5, delegate);
+		callGraphBuilder.setContextSelector(newContextSelector);
+	}
+
+	@Override
+	public void buildContextInterpretor() {
+		// stick with the default one.
+		// final RTAContextInterpreter contextInterpreter =
+		// callGraphBuilder.getContextInterpreter();
+	}
+
+	@Override
+	public void buildCallGraph() {
+		try {
+			callGraph = callGraphBuilder.makeCallGraph(options,
+					new IProgressMonitor() {
+
+						InterruptsCheckingProgressMonitor delegate = new InterruptsCheckingProgressMonitor();
+
+						@Override
+						public void worked(int units) {
+
+						}
+
+						@Override
+						public boolean isCanceled() {
+							return delegate.isCanceled();
+						}
+
+						@Override
+						public void done() {
+							// TODO Auto-generated method stub
+
+						}
+
+						@Override
+						public void beginTask(String task, int totalWork) {
+							// TODO Auto-generated method stub
+
+						}
+					});
+		} catch (final Exception e) {
+			throw Throws.throwUnhandledException(e);
+		}
+	}
+
+	@Override
+	public CallGraph getCallGraph() {
+		return callGraph;
+	}
+
+	@Override
+	public PointerAnalysis getPointerAnalysis() {
+		return callGraphBuilder.getPointerAnalysis();
+	}
 
 }
diff --git a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/utils/LocalNamesCollector.java b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/utils/LocalNamesCollector.java
index 92606ee..9e8240f 100644
--- a/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/utils/LocalNamesCollector.java
+++ b/org.eclipse.recommenders.commons.analysis/src/org/eclipse/recommenders/internal/commons/analysis/utils/LocalNamesCollector.java
@@ -15,6 +15,8 @@ import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 
+import org.eclipse.recommenders.commons.utils.Throws;
+
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.Multimap;
 import com.ibm.wala.ssa.IR;
@@ -90,6 +92,9 @@ public class LocalNamesCollector {
 
     private void collectLocalValueNames() {
         for (final Iterator<SSAInstruction> it = ir.iterateAllInstructions(); it.hasNext();) {
+        	if (Thread.currentThread().isInterrupted()) {
+                Throws.throwCancelationException();
+            }
             final SSAInstruction instr = it.next();
             {
                 // check for field access
-- 
1.6.3.3

