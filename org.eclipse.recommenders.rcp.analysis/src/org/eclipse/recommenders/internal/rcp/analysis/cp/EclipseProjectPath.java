/**
 * Copyright (c) 2010 Darmstadt University of Technology.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Marcel Bruch - initial API and implementation.
 */
package org.eclipse.recommenders.internal.rcp.analysis.cp;

import static org.eclipse.recommenders.commons.utils.Checks.ensureIsFalse;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.jar.JarFile;
import java.util.zip.ZipException;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.jdt.core.IClasspathContainer;
import org.eclipse.jdt.core.IClasspathEntry;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.osgi.service.resolver.BundleDescription;
import org.eclipse.pde.core.plugin.IPluginModelBase;
import org.eclipse.pde.internal.core.ClasspathUtilCore;
import org.eclipse.pde.internal.core.PDECore;
import org.eclipse.pde.internal.core.PDEStateHelper;

import com.ibm.wala.classLoader.BinaryDirectoryTreeModule;
import com.ibm.wala.classLoader.JarFileModule;
import com.ibm.wala.classLoader.Module;
import com.ibm.wala.client.AbstractAnalysisEngine;
import com.ibm.wala.ipa.callgraph.AnalysisScope;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.util.collections.HashSetFactory;
import com.ibm.wala.util.collections.MapUtil;
import com.ibm.wala.util.config.AnalysisScopeReader;
import com.ibm.wala.util.debug.Assertions;

/**
 * Representation of an analysis scope from an Eclipse project.
 * 
 * We set up classloaders as follows:
 * <ul>
 * <li>The project being analyzed is in the Application Loader
 * <li>Projects on which the main project depends are in the Extension loader
 * <li>System libraries are in the primordial loader.
 * <li>Source modules go in a special Source loader.
 * </ul>
 */
@SuppressWarnings("restriction")
public class EclipseProjectPath {

    /**
     * Eclipse projects are modelled with 3 loaders, as described above.
     */
    public enum Loader {
        APPLICATION(ClassLoaderReference.Application), EXTENSION(ClassLoaderReference.Extension), PRIMORDIAL(
                ClassLoaderReference.Primordial);

        private ClassLoaderReference ref;

        Loader(final ClassLoaderReference ref) {
            this.ref = ref;
        }
    };

    /**
     * The project whose path this object represents
     */
    private final IJavaProject project;

    /**
     * names of OSGi bundles already processed.
     */
    private final Set<String> bundlesProcessed = HashSetFactory.make();

    // SJF: Intentionally do not use HashMapFactory, since the Loader keys in
    // the following must use
    // identityHashCode. TODO: fix this source of non-determinism?
    private final Map<Loader, List<Module>> modules = new HashMap<Loader, List<Module>>();

    /**
     * Classpath entries that have already been resolved and added to the scope.
     */
    private final Collection<IClasspathEntry> alreadyResolved = HashSetFactory.make();

    /**
     * Should the analysis scope include source files
     */
    private final boolean includeSource;

    /**
     * Should the analysis scope include class files generated by the Eclipse
     * build process?
     */
    private final boolean includeClassFiles;

    protected EclipseProjectPath(final IJavaProject project, final boolean includeSource,
            final boolean includeClassFiles) throws IOException, CoreException {
        if (project == null) {
            throw new IllegalArgumentException("null project");
        }
        this.includeSource = includeSource;
        this.includeClassFiles = includeClassFiles;
        this.project = project;
        assert project != null;
        for (final Loader loader : Loader.values()) {
            MapUtil.findOrCreateList(modules, loader);
        }
        resolveProjectClasspathEntries(includeSource);
        if (isPluginProject(project)) {
            resolvePluginClassPath(project.getProject(), includeSource);
        }
    }

    private void resolveProjectClasspathEntries(final boolean includeSource) throws JavaModelException, IOException {
        resolveClasspathEntries(project.getResolvedClasspath(true), Loader.EXTENSION, includeSource);
    }

    protected void resolveClasspathEntries(final IClasspathEntry[] entries, final Loader loader,
            final boolean includeSource) throws JavaModelException, IOException {
        for (int i = 0; i < entries.length; i++) {
            resolveClasspathEntry(entries[i], loader, includeSource);
        }
    }

    /**
     * Figure out what a classpath entry means and add it to the appropriate set
     * of modules
     */
    private void resolveClasspathEntry(final IClasspathEntry entry, final Loader loader, final boolean includeSource)
            throws JavaModelException, IOException {
        // final IClasspathEntry e = JavaCore.getResolvedClasspathEntry(entry);
        // if (e == null) {
        // RecommendersPlugin.logWarning("Unable to resolve classpath entry '%s' in project '%s'. "
        // +
        // "To get recommendations for that project you have to fix the dependencies. "
        // + "After that close and reopen the project.", entry, project);
        // return;
        // }

        if (alreadyResolved.contains(entry)) {
            return;
        } else {
            alreadyResolved.add(entry);
        }

        if (entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER) {
            final IClasspathContainer cont = JavaCore.getClasspathContainer(entry.getPath(), project);
            final IClasspathEntry[] entries = cont.getClasspathEntries();
            resolveClasspathEntries(entries, cont.getKind() == IClasspathContainer.K_APPLICATION ? loader
                    : Loader.PRIMORDIAL, includeSource);
        } else if (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
            final File file = makeAbsolute(entry.getPath()).toFile();
            JarFile j;
            try {
                j = new JarFile(file);
            } catch (final ZipException z) {
                // a corrupted file. ignore it.
                return;
            } catch (final FileNotFoundException z) {
                // should ignore directories as well..
                return;
            }
            if (isPrimordialJarFile(j)) {
                final List<Module> s = MapUtil.findOrCreateList(modules, loader);
                s.add(file.isDirectory() ? (Module) new BinaryDirectoryTreeModule(file) : (Module) new JarFileModule(j));
            }
        } else if (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
            List<Module> s = MapUtil.findOrCreateList(modules, loader);

            if (includeSource) {
                s.add(new EclipseSourceDirectoryTreeModule(entry.getPath()));
            }
            if (entry.getOutputLocation() != null) {
                final File output = makeAbsolute(entry.getOutputLocation()).toFile();
                s = MapUtil.findOrCreateList(modules, loader);
                s.add(new BinaryDirectoryTreeModule(output));
            }
        } else if (entry.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
            final IPath projectPath = makeAbsolute(entry.getPath());
            final IWorkspace ws = ResourcesPlugin.getWorkspace();
            final IWorkspaceRoot root = ws.getRoot();
            final IProject project = (IProject) root.getContainerForLocation(projectPath);
            try {
                if (project.hasNature(JavaCore.NATURE_ID)) {
                    final IJavaProject javaProject = JavaCore.create(project);
                    if (isPluginProject(javaProject)) {
                        resolvePluginClassPath(javaProject.getProject(), includeSource);
                    }
                    resolveClasspathEntries(javaProject.getRawClasspath(), loader, includeSource);
                    final File output = makeAbsolute(javaProject.getOutputLocation()).toFile();
                    final List<Module> s = MapUtil.findOrCreateList(modules, loader);
                    if (output.exists()) {
                        s.add(new BinaryDirectoryTreeModule(output));
                    }
                }
            } catch (final CoreException e1) {
                e1.printStackTrace();
                // Assertions.UNREACHABLE();
            }
        } else if (entry.getEntryKind() == IClasspathEntry.CPE_VARIABLE) {
            final IClasspathEntry resolved = JavaCore.getResolvedClasspathEntry(entry);
            ensureIsFalse(resolved.getEntryKind() == IClasspathEntry.CPE_VARIABLE,
                    "failed assumption during resolving classpath entry " + entry);
            resolveClasspathEntry(resolved, loader, includeSource);

        } else {
            throw new RuntimeException("unexpected entry " + entry);
        }
    }

    /**
     * traverse the bundle description for an Eclipse project and populate the
     * analysis scope accordingly
     */
    private void resolvePluginClassPath(final IProject p, final boolean includeSource) throws CoreException,
            IOException {
        final IPluginModelBase model = findModel(p);
        if (!model.isInSync() || model.isDisposed()) {
            model.load();
        }
        BundleDescription bd = model.getBundleDescription();

        if (bd == null) {
            // temporary debugging code; remove once we figure out what the heck
            // is going on here --MS
            System.err.println("model.isDisposed(): " + model.isDisposed());
            System.err.println("model.isInSync(): " + model.isInSync());
            System.err.println("model.isEnabled(): " + model.isEnabled());
            System.err.println("model.isLoaded(): " + model.isLoaded());
            System.err.println("model.isValid(): " + model.isValid());
        }
        for (int i = 0; i < 3 && bd == null; i++) {
            // Uh oh. bd is null. Go to sleep, cross your fingers, and try
            // again.
            // This is horrible. We can't figure out the race condition yet
            // which causes this to happen.
            try {
                Thread.sleep(5000);
            } catch (final InterruptedException e) {
                // whatever.
            }
            bd = findModel(p).getBundleDescription();
        }

        if (bd == null) {
            throw new IllegalStateException("bundle description was null for " + p);
        }
        resolveBundleDescriptionClassPath(bd, Loader.APPLICATION, includeSource);
    }

    /**
     * traverse a bundle description and populate the analysis scope accordingly
     */
    private void resolveBundleDescriptionClassPath(final BundleDescription bd, final Loader loader,
            final boolean includeSource) throws CoreException, IOException {
        assert bd != null;
        if (alreadyProcessed(bd)) {
            return;
        }
        bundlesProcessed.add(bd.getName());

        // handle the classpath entries for bd
        @SuppressWarnings("rawtypes")
        final ArrayList l = new ArrayList();
        ClasspathUtilCore.addLibraries(findModel(bd), l);
        final IClasspathEntry[] entries = new IClasspathEntry[l.size()];
        int i = 0;
        for (final Object o : l) {
            final IClasspathEntry e = (IClasspathEntry) o;
            entries[i++] = e;
        }
        resolveClasspathEntries(entries, loader, includeSource);

        // recurse to handle dependencies. put these in the Extension loader
        for (final BundleDescription b : PDEStateHelper.getImportedBundles(bd)) {
            resolveBundleDescriptionClassPath(b, Loader.EXTENSION, includeSource);
        }
        for (final BundleDescription b : bd.getResolvedRequires()) {
            resolveBundleDescriptionClassPath(b, Loader.EXTENSION, includeSource);
        }
        for (final BundleDescription b : bd.getFragments()) {
            resolveBundleDescriptionClassPath(b, Loader.EXTENSION, includeSource);
        }
    }

    public static IPath makeAbsolute(final IPath p) {
        IPath absolutePath = p;
        if (p.toFile().exists()) {
            return p;
        }

        final IResource resource = ResourcesPlugin.getWorkspace().getRoot().findMember(p);
        if (resource != null && resource.exists()) {
            absolutePath = resource.getLocation();
        }
        return absolutePath;
    }

    /**
     * @return true if the given jar file should be handled by the Primordial
     *         loader. If false, other provisions should be made to add the jar
     *         file to the appropriate component of the AnalysisScope.
     *         Subclasses can override this method.
     */
    protected boolean isPrimordialJarFile(final JarFile j) {
        return true;
    }

    /**
     * Is javaProject a plugin project?
     */
    private boolean isPluginProject(final IJavaProject javaProject) {
        final IPluginModelBase model = findModel(javaProject.getProject());
        if (model == null) {
            return false;
        }
        if (model.getPluginBase().getId() == null) {
            return false;
        }
        return true;
    }

    private IPluginModelBase findModel(final IProject p) {
        // PluginRegistry is specific to Eclipse 3.3+. Use PDECore for
        // compatibility with 3.2
        // return PluginRegistry.findModel(p);
        return PDECore.getDefault().getModelManager().findModel(p);
    }

    /**
     * have we already processed a particular bundle description?
     */
    private boolean alreadyProcessed(final BundleDescription bd) {
        return bundlesProcessed.contains(bd.getName());
    }

    private IPluginModelBase findModel(final BundleDescription bd) {
        // PluginRegistry is specific to Eclipse 3.3+. Use PDECore for
        // compatibility with 3.2
        // return PluginRegistry.findModel(bd);
        return PDECore.getDefault().getModelManager().findModel(bd);
    }

    public AnalysisScope toAnalysisScope() throws IOException {
        return toAnalysisScope(getClass().getClassLoader(), null);
    }

    @Override
    public String toString() {
        try {
            return toAnalysisScope((File) null).toString();
        } catch (final IOException e) {
            e.printStackTrace();
            return "Error in toString()";
        }
    }

    public AnalysisScope toAnalysisScope(final File exclusionsFile) throws IOException {
        return toAnalysisScope(getClass().getClassLoader(), exclusionsFile);
    }

    /**
     * Convert this path to a WALA analysis scope
     * 
     * @throws IOException
     */
    public AnalysisScope toAnalysisScope(final ClassLoader classLoader, final File exclusionsFile) throws IOException {
        final AnalysisScope scope = AnalysisScopeReader.readJavaScope(AbstractAnalysisEngine.SYNTHETIC_J2SE_MODEL,
                exclusionsFile, classLoader);
        return toAnalysisScope(scope);
    }

    public AnalysisScope toAnalysisScope(final AnalysisScope scope) {
        try {
            final List<Module> l = MapUtil.findOrCreateList(modules, Loader.APPLICATION);
            if (includeClassFiles) {
                final File dir = makeAbsolute(project.getOutputLocation()).toFile();
                if (!dir.isDirectory()) {
                    System.err.println("PANIC: project output location is not a directory: " + dir);
                } else {
                    l.add(new BinaryDirectoryTreeModule(dir));
                }
            }

            if (includeSource) {
                for (final IClasspathEntry e : project.getRawClasspath()) {
                    if (e.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
                        l.add(new EclipseSourceDirectoryTreeModule(e.getPath()));
                    }
                }
            }

            for (final Loader loader : Loader.values()) {
                for (final Module m : modules.get(loader)) {
                    scope.addToScope(loader.ref, m);
                }
            }
            return scope;
        } catch (final JavaModelException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
            return null;
        }
    }

    public static EclipseProjectPath make(final IJavaProject project) throws IOException, CoreException {
        return make(project, false, true);
    }

    public static EclipseProjectPath make(final IJavaProject project, final boolean includeSource,
            final boolean includeClassFiles) throws IOException, CoreException {
        return new EclipseProjectPath(project, includeSource, includeClassFiles);
    }

    public Collection<Module> getModules(final Loader loader, final boolean binary) {
        return Collections.unmodifiableCollection(modules.get(loader));
    }
}
